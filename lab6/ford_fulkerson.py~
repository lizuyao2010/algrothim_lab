def ford_fulkerson(G,s,t):
    #Gf=redisdualgraph(G)
    #(id,flow,residual)
    Gf=G
    path = find_path(Gf,s,t)
    print path
   
    while path:
        Gf=augment(path,Gf)
        path = find_path(Gf,s,t)

    print Gf

def update(node1,node2,minresidual,Gf):
	for edge in Gf[node1]:
		if edge[0]==node2:
			edge[1]+=minresidual
			edge[2]-=minresidual
	return Gf

def augment(path,Gf):
	minresidual = path[1][1]
    for i in range(2,len(path)):
        if path[i][1]< minresidual:
        	minresidual=path[i][1]

    for i in range(len(path)):
    	Gf=update(path[i],path[i+1],minresidual,Gf)

    return Gf
        

def find_path(graph, start, end, path=[],edgelen=0):
    path = path + [(start,edgelen)]
    if start == end:
        return path
    if not graph.has_key(start):
        return None
    for node in graph[start]:
        if node[0] not in path and node[2]>0:
            newpath = find_path(graph, node[0], end, path, node[2])
            if newpath: return newpath
    return None

def redisdualgraph(graph):
    G=dict()
    for key in graph.keys():
        G[key]=[]
    for key in graph.keys():
        values=graph[key]
        for value in values:
            #(id,residual)
            G[key].append((value[0],value[2]))
            #(key,flow)
            G[value[0]].append((key,value[1]))
    return G

if __name__=='__main__':
    # (id,flow,capcity)
    graph = {1: [[2,0,10],[3,0,10],
             2: [[3,0,2],[4,0,4],[5,0,8]],
             3: [[5,0,9]],
             4: [[6,0,10]],
             5: [[4,0,6],[6,0,10]],
             6: []}
    
    ford_fulkerson(graph,1,6)
